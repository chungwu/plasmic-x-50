"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixComponentImagesReferences = exports.fixComponentCssReferences = exports.syncProjectImageAssets = void 0;
const promise_pool_1 = require("@supercharge/promise-pool");
const cli_progress_1 = __importDefault(require("cli-progress"));
const lodash_1 = __importDefault(require("lodash"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const config_utils_1 = require("../utils/config-utils");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
function syncProjectImageAssets(context, projectId, branchName, version, imageBundles, checksums) {
    return __awaiter(this, void 0, void 0, function* () {
        const project = config_utils_1.getOrAddProjectConfig(context, projectId);
        const projectLock = config_utils_1.getOrAddProjectLock(context, projectId, branchName);
        const knownImageConfigs = lodash_1.default.keyBy(project.images, (i) => i.id);
        const imageBundleIds = lodash_1.default.keyBy(imageBundles, (i) => i.id);
        const imageFileLocks = lodash_1.default.keyBy(projectLock.fileLocks.filter((fileLock) => fileLock.type === "image"), (fl) => fl.assetId);
        const id2ImageChecksum = new Map(checksums.imageChecksums);
        const deletedImages = lodash_1.default.filter(knownImageConfigs, (i) => !imageBundleIds[i.id] && !id2ImageChecksum.has(i.id));
        yield ensureImageAssetContents(imageBundles);
        for (const bundle of imageBundles) {
            if (context.cliArgs.quiet !== true) {
                deps_1.logger.info(`Syncing image: ${bundle.name}@${version}\t['${project.projectName}' ${project.projectId}/${bundle.id} ${project.version}]`);
            }
            let imageConfig = knownImageConfigs[bundle.id];
            const isNew = !imageConfig;
            const defaultFilePath = context.config.images.scheme === "public-files"
                ? file_utils_1.defaultPublicResourcePath(context, project, "images", bundle.fileName)
                : file_utils_1.defaultResourcePath(context, project, "images", bundle.fileName);
            if (isNew) {
                imageConfig = {
                    id: bundle.id,
                    name: bundle.name,
                    filePath: defaultFilePath,
                };
                project.images.push(imageConfig);
            }
            else {
                const filePath = upath_1.default.join(upath_1.default.dirname(imageConfig.filePath), upath_1.default.basename(defaultFilePath));
                if (imageConfig.filePath !== filePath &&
                    file_utils_1.fileExists(context, imageConfig.filePath)) {
                    if (context.cliArgs.quiet !== true) {
                        deps_1.logger.info(`Renaming image: ${imageConfig.name}@${version}\t['${project.projectName}' ${project.projectId}/${bundle.id} ${project.version}]`);
                    }
                    file_utils_1.renameFile(context, imageConfig.filePath, filePath);
                    imageConfig.filePath = filePath;
                }
                imageConfig.name = bundle.name;
            }
            // Update FileLocks
            if (imageFileLocks[bundle.id]) {
                imageFileLocks[bundle.id].checksum = lang_utils_1.ensure(id2ImageChecksum.get(bundle.id));
            }
            else {
                projectLock.fileLocks.push({
                    type: "image",
                    assetId: bundle.id,
                    checksum: lang_utils_1.ensure(id2ImageChecksum.get(bundle.id)),
                });
            }
            yield file_utils_1.writeFileContent(context, imageConfig.filePath, Buffer.from(bundle.blob, "base64"), {
                force: !isNew,
            });
        }
        const deletedImageFiles = new Set();
        for (const deletedImage of deletedImages) {
            const imageConfig = knownImageConfigs[deletedImage.id];
            if (file_utils_1.fileExists(context, imageConfig.filePath)) {
                deps_1.logger.info(`Deleting image: ${imageConfig.name}@${version}\t['${project.projectName}' ${project.projectId}/${deletedImage.id} ${project.version}]`);
                file_utils_1.deleteFile(context, imageConfig.filePath);
                deletedImageFiles.add(deletedImage.id);
            }
        }
        project.images = project.images.filter((i) => !deletedImageFiles.has(i.id));
        const deletedImageIds = new Set(deletedImages.map((i) => i.id));
        projectLock.fileLocks = projectLock.fileLocks.filter((fileLock) => fileLock.type !== "image" || !deletedImageIds.has(fileLock.assetId));
    });
}
exports.syncProjectImageAssets = syncProjectImageAssets;
function ensureImageAssetContents(bundles) {
    return __awaiter(this, void 0, void 0, function* () {
        // The server may send images as a url instead of a base64 blob. In that
        // case, we fetch the images here in the cli, instead of on the server.
        // If you have a lot of images, this moves the expensive / long fetch
        // from the codegen server to the cli
        const needsFetching = bundles.filter((b) => b.blob.startsWith("https://site-assets.plasmic.app/"));
        if (needsFetching.length === 0) {
            return;
        }
        const bar = new cli_progress_1.default.SingleBar({
            format: `Downloading images [{bar}] | {value}/{total}`,
        });
        bar.start(needsFetching.length, 0);
        yield new promise_pool_1.PromisePool()
            .withConcurrency(10)
            .for(needsFetching)
            .process((bundle) => __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield node_fetch_1.default(bundle.blob);
                if (res.status !== 200) {
                    throw new Error(`Fetching ${bundle.blob} failed with status ${res.status}`);
                }
                const arrayBuffer = yield res.arrayBuffer();
                bundle.blob = Buffer.from(arrayBuffer).toString("base64");
                bar.increment();
            }
            catch (err) {
                deps_1.logger.error(`Failed to fetch image ${bundle.fileName}: ${err}`);
                throw err;
            }
        }));
        bar.stop();
    });
}
function getImagePublicUrl(context, asset) {
    return (lang_utils_1.ensure(context.config.images.publicUrlPrefix) +
        (lang_utils_1.ensure(context.config.images.publicUrlPrefix).endsWith("/") ? "" : "/") +
        upath_1.default.relative(lang_utils_1.ensure(context.config.images.publicDir), asset.filePath));
}
const RE_ASSETCSSREF_ALL = /var\(--image-([^\)]+)\)/g;
function fixComponentCssReferences(context, fixImportContext, cssFilePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!file_utils_1.fileExists(context, cssFilePath)) {
            return;
        }
        const prevContent = file_utils_1.readFileContent(context, cssFilePath);
        const newContent = prevContent.replace(RE_ASSETCSSREF_ALL, (sub, assetId) => {
            const asset = fixImportContext.images[assetId];
            if (asset) {
                return context.config.images.scheme === "public-files"
                    ? `url("${getImagePublicUrl(context, asset)}")`
                    : `url("./${upath_1.default.relative(upath_1.default.dirname(cssFilePath), asset.filePath)}")`;
            }
            else {
                return sub;
            }
        });
        if (prevContent !== newContent) {
            yield file_utils_1.writeFileContent(context, cssFilePath, newContent, { force: true });
        }
    });
}
exports.fixComponentCssReferences = fixComponentCssReferences;
const RE_ASSETTSXREF_ALL = /Plasmic_Image_([^\)\s]+)__Ref/g;
function fixComponentImagesReferences(context, fixImportContext, renderModuleFilePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const prevContent = file_utils_1.readFileContent(context, renderModuleFilePath);
        const newContent = prevContent.replace(RE_ASSETTSXREF_ALL, (sub, assetId) => {
            const asset = fixImportContext.images[assetId];
            if (asset) {
                return getImagePublicUrl(context, asset);
            }
            else {
                return sub;
            }
        });
        if (prevContent !== newContent) {
            yield file_utils_1.writeFileContent(context, renderModuleFilePath, newContent, {
                force: true,
            });
            // Returns true if the content changed
            return true;
        }
        return false;
    });
}
exports.fixComponentImagesReferences = fixComponentImagesReferences;
