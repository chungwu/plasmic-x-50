"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectPackageManager = exports.installCommand = exports.installUpgrade = exports.findPackageJsonDir = exports.isCliGloballyInstalled = exports.findInstalledVersion = exports.getParsedPackageJson = exports.checkEngineStrict = exports.getCliVersion = exports.getParsedCliPackageJson = void 0;
const child_process_1 = require("child_process");
const findup_sync_1 = __importDefault(require("findup-sync"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const deps_1 = require("../deps");
const file_utils_1 = require("./file-utils");
function getParsedCliPackageJson() {
    const packageJson = findup_sync_1.default("package.json", { cwd: __dirname });
    if (!packageJson) {
        throw new Error(`Cannot find package.json in ancestors of ${__dirname}`);
    }
    return parsePackageJson(packageJson);
}
exports.getParsedCliPackageJson = getParsedCliPackageJson;
function getCliVersion() {
    const j = getParsedCliPackageJson();
    return j.version;
}
exports.getCliVersion = getCliVersion;
/**
 * Call this to check if we match the engine policy
 */
function checkEngineStrict() {
    var _a;
    const pkg = getParsedCliPackageJson();
    const minNodeVersion = (_a = pkg === null || pkg === void 0 ? void 0 : pkg.engines) === null || _a === void 0 ? void 0 : _a.node;
    if (!!minNodeVersion && !semver_1.default.satisfies(process.version, minNodeVersion)) {
        deps_1.logger.warn(`Plasmic only works on Node ${minNodeVersion}`);
        return false;
    }
    return true;
}
exports.checkEngineStrict = checkEngineStrict;
function getParsedPackageJson() {
    const packageJson = findup_sync_1.default("package.json");
    if (!packageJson) {
        throw new Error(`Cannot find package.json`);
    }
    return parsePackageJson(packageJson);
}
exports.getParsedPackageJson = getParsedPackageJson;
function findInstalledVersion(config, baseDir, pkg) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const pm = detectPackageManager(config, baseDir);
    try {
        if (pm === "yarn2") {
            const output = child_process_1.execSync(`yarn info --json ${pkg}`).toString().trim();
            const info = JSON.parse(output);
            return (_a = info === null || info === void 0 ? void 0 : info.children) === null || _a === void 0 ? void 0 : _a.Version;
        }
        else if (pm === "yarn") {
            const output = child_process_1.execSync(`yarn list --json --pattern ${pkg}`)
                .toString()
                .trim()
                .split("\n");
            for (const line of output) {
                const info = JSON.parse(line);
                if ((info === null || info === void 0 ? void 0 : info.type) === "tree" && ((_e = (_d = (_c = (_b = info === null || info === void 0 ? void 0 : info.data) === null || _b === void 0 ? void 0 : _b.trees) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.name) === null || _e === void 0 ? void 0 : _e.startsWith(`${pkg}@`))) {
                    return info.data.trees[0].name.replace(`${pkg}@`, "");
                }
            }
        }
        else if (pm === "npm") {
            const output = child_process_1.execSync(`npm list --package-lock-only --json ${pkg}`)
                .toString()
                .trim();
            const info = JSON.parse(output);
            return (_g = (_f = info === null || info === void 0 ? void 0 : info.dependencies) === null || _f === void 0 ? void 0 : _f[pkg]) === null || _g === void 0 ? void 0 : _g.version;
        }
        else {
            // Unknown package manager (e.g. pnpm).
            const output = child_process_1.execSync(`npm list --json ${pkg}`).toString().trim();
            const info = JSON.parse(output);
            return (_j = (_h = info === null || info === void 0 ? void 0 : info.dependencies) === null || _h === void 0 ? void 0 : _h[pkg]) === null || _j === void 0 ? void 0 : _j.version;
        }
    }
    catch (err) {
        deps_1.logger.warn(`Could not detect installed version of ${pkg} using ${pm}: ${err}`);
    }
    return undefined;
}
exports.findInstalledVersion = findInstalledVersion;
/**
 * Detects if the cli is globally installed.  `rootDir` is the folder
 * where plasmic.json is
 */
function isCliGloballyInstalled(rootDir) {
    const packageJsonFile = findPackageJsonPath(rootDir);
    if (!packageJsonFile) {
        // We assume global, as instructions state global and we can't really
        // do better
        return true;
    }
    const installedDir = __dirname;
    // Else, we assume it is local if the installedDir is a subfolder of
    // the root project dir
    return !installedDir.startsWith(path_1.default.dirname(packageJsonFile));
}
exports.isCliGloballyInstalled = isCliGloballyInstalled;
function findPackageJsonPath(dir) {
    return file_utils_1.findFile(dir, (f) => f === "package.json", {
        traverseParents: true,
    });
}
function findPackageJsonDir(rootDir) {
    const filePath = findPackageJsonPath(rootDir);
    return filePath ? path_1.default.dirname(filePath) : undefined;
}
exports.findPackageJsonDir = findPackageJsonDir;
function parsePackageJson(path) {
    try {
        return JSON.parse(file_utils_1.readFileText(path));
    }
    catch (e) {
        return undefined;
    }
}
function installUpgrade(config, pkg, baseDir, opts = {}) {
    const cmd = installCommand(config, pkg, baseDir, opts);
    if (!process.env.QUIET) {
        deps_1.logger.info(cmd);
    }
    const r = child_process_1.spawnSync(cmd, {
        shell: true,
        stdio: process.env.QUIET ? "ignore" : "inherit",
        cwd: baseDir,
    });
    if (r.status === 0) {
        if (!process.env.QUIET) {
            deps_1.logger.info(`Successfully added ${pkg} dependency.`);
        }
        return true;
    }
    else {
        deps_1.logger.warn(`Cannot add ${pkg} to your project dependencies. Please add it manually.`);
        return false;
    }
}
exports.installUpgrade = installUpgrade;
function installCommand(config, pkg, baseDir, opts = {}) {
    const mgr = detectPackageManager(config, baseDir);
    if (mgr === "yarn") {
        if (opts.global) {
            return `yarn global add ${pkg}`;
        }
        else if (opts.dev) {
            return `yarn add --dev --ignore-scripts -W ${pkg}`;
        }
        else {
            return `yarn add --ignore-scripts -W ${pkg}`;
        }
    }
    else if (mgr === "yarn2") {
        if (opts.global) {
            // yarn2 does not support global.
            return `npm install -g ${pkg}`;
        }
        else if (opts.dev) {
            return `yarn add -D ${pkg}`;
        }
        else {
            return `yarn add ${pkg}`;
        }
    }
    else {
        if (opts.global) {
            return `npm install -g ${pkg}`;
        }
        else if (opts.dev) {
            return `npm install --save-dev --ignore-scripts ${pkg}`;
        }
        else {
            return `npm install --ignore-scripts ${pkg}`;
        }
    }
}
exports.installCommand = installCommand;
function detectPackageManager(config, baseDir) {
    if (config.packageManager) {
        return config.packageManager;
    }
    const yarnLock = findup_sync_1.default("yarn.lock", { cwd: baseDir });
    if (yarnLock) {
        const yarnVersion = child_process_1.execSync(`yarn --version`).toString().trim();
        if (semver_1.default.gte(yarnVersion, "2.0.0")) {
            return "yarn2";
        }
        else {
            return "yarn";
        }
    }
    const npmLock = findup_sync_1.default("package-lock.json", { cwd: baseDir });
    if (npmLock) {
        return "npm";
    }
    return "unknown";
}
exports.detectPackageManager = detectPackageManager;
